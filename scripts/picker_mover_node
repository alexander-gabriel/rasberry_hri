#!/usr/bin/env python

import sys
import os
from math import sin, cos, pi, sqrt
from threading import Thread
from time import sleep
# from time import sleep

import rospy
import rosbag
from geometry_msgs.msg import Pose
from marvelmind_nav.msg import hedge_pos_a
from rasberry_hri.msg import Action

from common.parameters import NS, PICKER_LENGTH, ROBOT_LENGTH, \
    INITIAL_PICKER_POSITION, INITIAL_PICKER_ORIENTATION, \
    PICKER_DISTANCE_PREFERENCE, ME, PICKER_WIDTH, ROBOT_WIDTH, TARGET_PICKER
from common.utils import db

SLEEP = 0.01

MEAN_WAYPOINT_DISTANCE = rospy.get_param(
    "{}/mean_waypoint_distance".format(NS), 2.95)  # m
FREQUENCY = 10  # Hz  1/s
PICKER_SPEED = rospy.get_param("{}/picker_speed".format(NS), 0.7)  # m/s
PICKER_ID = 2

EVADE_DISTANCE = 2 * MEAN_WAYPOINT_DISTANCE  # m
EVADE_COUNTS = int(EVADE_DISTANCE / PICKER_SPEED * FREQUENCY)

DELIVER_DISTANCE = 1 * MEAN_WAYPOINT_DISTANCE  # m
DELIVER_COUNTS = int(DELIVER_DISTANCE / PICKER_SPEED * FREQUENCY)

EXCHANGE_DISTANCE = 1 * MEAN_WAYPOINT_DISTANCE  # m
EXCHANGE_COUNTS = int(EXCHANGE_DISTANCE / PICKER_SPEED * FREQUENCY)
EXCHANGE_WAIT_COUNTS = (rospy.get_param("{}/exchange_cost".format(NS), 5)
                        * FREQUENCY)
DELIVER_WAIT_COUNTS = (rospy.get_param("{}/give_cost".format(NS), 5)
                       * FREQUENCY)


ANGLE = 0.0  # angle between direction of travel and X coordinate
X_DISTANCE = cos(ANGLE) * PICKER_SPEED / FREQUENCY
Y_DISTANCE = sin(ANGLE) * PICKER_SPEED / FREQUENCY


# 102: 8.675 4.65
# 103: 11.649 4.64
# 104: 14.12 4.612
# 105: 17.061 4.609 ,_ was this
# 106: 19.997 4.568


data = {
    "picking": {
        1: {
            "standing": (
                "/data/subject-1-out/picking_berries-34-joints.bag",
                1,
                3,
            ),
            "moving": (
                "/data/subject-1-moving-out/picking_berries-39-joints.bag",
                5,
                3,
            ),
        },
        2: {
            "standing": (
                "/data/subject-2-out/picking_berries-14-joints.bag",
                1,
                3,
            ),
            "moving": (
                "/data/subject-2-moving-out/picking_berries-10-joints.bag",
                1,
                3,
            ),
        },
        3: {
            "standing": (
                "/data/subject-3-out/picking_berries-16-joints.bag",
                5,
                3,
            ),
            "moving": (
                "/data/subject-3-moving-out/picking_berries-24-joints.bag",
                1,
                3,
            ),
        },
        4: {
            "standing": (
                "/data/subject-4-out/picking_berries-20-joints.bag",
                1,
                3,
            ),
            "moving": (
                "/data/subject-4-moving-out/picking_berries-25-joints.bag",
                1,
                3,
            ),
        },
        5: {
            "standing": (
                "/data/subject-5-out/picking_berries-15-joints.bag",
                1,
                3,
            ),
            "moving": (
                "/data/subject-5-moving-out/picking_berries-23-joints.bag",
                1,
                3,
            ),
        },
        6: {
            "standing": (
                "/data/subject-6-out/picking_berries-17-joints.bag",
                1,
                3,
            ),
            "moving": (
                "/data/subject-6-moving-out/picking_berries-17-joints.bag",
                3,
                3,
            ),
        },
        7: {
            "standing": (
                "/data/subject-7-out/picking_berries-17-joints.bag",
                1,
                3,
            ),
            "moving": (
                "/data/subject-7-moving-out/picking_berries-49-joints.bag",
                1,
                3,
            ),
        },
        8: {
            "standing": (
                "/data/subject-8-out/picking_berries-16-joints.bag",
                1,
                3,
            ),
            "moving": (
                "/data/subject-8-moving-out/picking_berries-24-joints.bag",
                3,
                3,
            ),
        },
        9: {
            "standing": (
                "/data/subject-9-out/picking_berries-22-joints.bag",
                3,
                3,
            ),
            "moving": (
                "/data/subject-9-moving-out/picking_berries-32-joints.bag",
                9,
                3,
            ),
        },
        10: {
            "standing": (
                "/data/subject-10-out/picking_berries-18-joints.bag",
                2,
                3,
            ),
            "moving": (
                "/data/subject-10-moving-out/picking_berries-23-joints.bag",
                1,
                3,
            ),
        },
    },
    "calling": {
        1: {
            "standing": (
                "/data/subject-1-out/gesture_call-75-joints.bag",
                1,
                3,
            ),
            "moving": (
                "/data/subject-1-moving-out/gesture_call-116-joints.bag",
                3,
                3,
            ),
        },
        2: {
            "standing": (
                "/data/subject-1-out/gesture_call-92-joints.bag",
                1,
                3,
            ),
            "moving": (
                "/data/subject-2-moving-out/gesture_call-123-joints.bag",
                1,
                3,
            ),
        },
        3: {
            "standing": (
                "/data/subject-3-out/gesture_call-50-joints.bag",
                1,
                3,
            ),
            "moving": (
                "/data/subject-1-moving-out/gesture_call-116-joints.bag",
                3,
                3,
            ),
        },
        4: {
            "standing": (
                "/data/subject-4-out/gesture_call-57-joints.bag",
                1,
                3,
            ),
            "moving": (
                "/data/subject-4-moving-out/gesture_call-116-joints.bag",
                1,
                3,
            ),
        },
        5: {
            "standing": (
                "/data/subject-5-out/gesture_call-50-joints.bag",
                1,
                3,
            ),
            "moving": (
                "/data/subject-5-moving-out/gesture_call-190-joints.bag",
                6,
                3,
            ),
        },
        6: {
            "standing": (
                "/data/subject-6-out/gesture_call-56-joints.bag",
                1,
                3,
            ),
            "moving": (
                "/data/subject-6-moving-out/gesture_call-110-joints.bag",
                1,
                3,
            ),
        },
        7: {
            "standing": (
                "/data/subject-7-out/gesture_call-48-joints.bag",
                1,
                3,
            ),
            "moving": (
                "/data/subject-7-moving-out/gesture_call-123-joints.bag",
                5,
                3,
            ),
        },
        8: {
            "standing": (
                "/data/subject-8-out/gesture_call-53-joints.bag",
                1,
                3,
            ),
            "moving": (
                "/data/subject-8-moving-out/gesture_call-92-joints.bag",
                1,
                3,
            ),
        },
        9: {
            "standing": (
                "/data/subject-9-out/gesture_call-99-joints.bag",
                1,
                3,
            ),
            "moving": (
                "/data/subject-9-moving-out/gesture_call-156-joints.bag",
                1,
                3,
            ),
        },
        10: {
            "standing": (
                "/data/subject-10-out/gesture_call-52-joints.bag",
                1,
                3,
            ),
            "moving": (
                "/data/subject-10-moving-out/gesture_call-126-joints.bag",
                1,
                3,
            ),
        },
    },
}

picks = {}
calls = {}
for subject_id in range(1, 10 + 1):
    picks[subject_id] = {}
    calls[subject_id] = {}
    for mode in ["standing", "moving"]:
        filename, start, duration = data["picking"][subject_id][mode]
        picks[subject_id][mode] = {
            "type": "rosbag",
            "label": "picking_berries",
            "start": start,
            "duration": duration,
            "filename": filename,
            "topics": ["/human_actions"],
        }
        filename, start, duration = data["calling"][subject_id][mode]
        calls[subject_id][mode] = {
            "type": "rosbag",
            "label": "calling",
            "start": start,
            "duration": duration,
            "filename": filename,
            "topics": ["/human_actions"],
        }

picking_filenames = [
        "subject-10-moving-out/picking_berries-23-joints.bag",
        "subject-10-out/picking_berries-18-joints.bag",
        "subject-1-moving-out/picking_berries-39-joints.bag",
        "subject-1-out/picking_berries-34-joints.bag",
        "subject-2-moving-out/picking_berries-10-joints.bag",
        "subject-2-out/picking_berries-14-joints.bag",
        "subject-3-moving-out/picking_berries-24-joints.bag",
        "subject-3-out/picking_berries-16-joints.bag",
        "subject-4-moving-out/picking_berries-25-joints.bag",
        "subject-4-out/picking_berries-20-joints.bag",
        "subject-5-moving-out/picking_berries-23-joints.bag",
        "subject-5-out/picking_berries-15-joints.bag",
        "subject-6-moving-out/picking_berries-17-joints.bag",
        "subject-6-out/picking_berries-17-joints.bag",
        "subject-7-moving-out/picking_berries-49-joints.bag",
        "subject-7-out/picking_berries-17-joints.bag",
        "subject-8-moving-out/picking_berries-24-joints.bag",
        "subject-8-out/picking_berries-16-joints.bag",
        "subject-9-moving-out/picking_berries-32-joints.bag",
        "subject-9-out/picking_berries-22-joints.bag",
]


call_filenames = [
        "subject-10-moving-out/gesture_call-126-joints.bag",
        "subject-10-out/gesture_call-52-joints.bag",
        "subject-1-moving-out/gesture_call-116-joints.bag",
        "subject-1-moving-out/gesture_call-72-joints.bag",
        "subject-1-out/gesture_call-75-joints.bag",
        "subject-1-out/gesture_call-92-joints.bag",
        "subject-2-moving-out/gesture_call-123-joints.bag",
        "subject-3-out/gesture_call-50-joints.bag",
        "subject-4-moving-out/gesture_call-116-joints.bag",
        "subject-4-out/gesture_call-57-joints.bag",
        "subject-5-moving-out/gesture_call-186-joints.bag",
        "subject-5-moving-out/gesture_call-190-joints.bag",
        "subject-5-out/gesture_call-50-joints.bag",
        "subject-6-moving-out/gesture_call-110-joints.bag",
        "subject-6-out/gesture_call-56-joints.bag",
        "subject-7-moving-out/gesture_call-123-joints.bag",
        "subject-7-out/gesture_call-48-joints.bag",
        "subject-8-moving-out/gesture_call-92-joints.bag",
        "subject-8-out/gesture_call-53-joints.bag",
        "subject-9-moving-out/gesture_call-132-joints.bag",
        "subject-9-moving-out/gesture_call-156-joints.bag",
        "subject-9-out/gesture_call-78-joints.bag",
        "subject-9-out/gesture_call-99-joints.bag",
        ]



ACTIONS = {
    "pick berries": {
        "rosbag": {
            "filepath": "",
            "topics": [],
            "start": 0,
            "duration": 0
            },
        "movement pattern": "picking",
        "duration": 6  # seconds
    },
    "approach with crate": {
        "rosbag": {
            "filepath": "",
            "topics": [],
            "start": 0,
            "duration": 0
            },
        "movement pattern": "approach with crate",
        "duration": 6  # seconds
    },
    "pass with crate": {
        "rosbag": {
            "filepath": "",
            "topics": [],
            "start": 0,
            "duration": 0
            },
        "movement pattern": "pass with crate",
        "duration": 6  # seconds
    },
    "approach without crate": {
        "rosbag": {
            "filepath": "",
            "topics": [],
            "start": 0,
            "duration": 0
            },
        "movement pattern": "approach without crate",
        "duration": 6  # seconds
    },
    "leave with crate": {
        "rosbag": {
            "filepath": "",
            "topics": [],
            "start": 0,
            "duration": 0
            },
        "movement pattern": "leave with crate",
        "duration": 6  # seconds
    },
    "leave without crate": {
        "rosbag": {
            "filepath": "",
            "topics": [],
            "start": 0,
            "duration": 0
            },
        "movement pattern": "leave without crate",
        "duration": 6  # seconds
    },
    "call robot": {
        "rosbag": {
            "filepath": "",
            "topics": [],
            "start": 0,
            "duration": 0
            },
        "movement pattern": "call robot",
        "duration": 6  # seconds
    },
    "wait for robot": {
        "rosbag": {
            "filepath": "",
            "topics": [],
            "start": 0,
            "duration": 0
            },
        "movement pattern": "wait for robot",
        "duration": 6  # seconds
    }
}


def do_pick_berries(self):
    self.orientation = 1 * pi
    if not self.play_rosbags:
        msg = Action()
        msg.header.stamp = rospy.get_rostime()
        msg.action = "picking berries"
        msg.person = TARGET_PICKER
        self.human_action_pub.publish(msg)
        sleep(1)
    return True


def do_leave_robot(self):
    if self.x < INITIAL_PICKER_POSITION[0]:
        self.x += X_DISTANCE
        self.y += Y_DISTANCE
        self.orientation = 0 * pi
        return False
    else:
        # self.counter = 0
        return True


def do_approach_robot(self):
    distance = self.get_distance_to_robot()
    # if self.counter < EXCHANGE_COUNTS:
    if distance > PICKER_DISTANCE_PREFERENCE:
        self.x -= X_DISTANCE
        self.y -= Y_DISTANCE
        self.orientation = 2 * pi
        # self.counter += 1
        # self.wait = 0
        return False
    else:
        return True


def do_pass_robot(self):
    if (self.counter < EVADE_COUNTS):
        self.x -= X_DISTANCE
        self.y -= Y_DISTANCE
        self.orientation = 2 * pi
        self.counter += 1
        # self.wait = 0
        return False
    else:
        return True


def do_call_robot(self):
    self.orientation = 2 * pi
    if not self.play_rosbags:
        msg = Action()
        msg.header.stamp = rospy.get_rostime()
        msg.action = "calling"
        msg.person = TARGET_PICKER
        self.human_action_pub.publish(msg)
        sleep(1)
    return True


def do_wait_for_robot(self):
    self.orientation = 2 * pi
    return True


def do_reset(self):
    self.x = INITIAL_PICKER_POSITION[0]
    self.y = INITIAL_PICKER_POSITION[1]
    self.orientation = INITIAL_PICKER_ORIENTATION
    return True


BEHAVIOURS = {"pick berries": do_pick_berries,
              "leave robot": do_leave_robot,
              "approach robot": do_approach_robot,
              "pass robot": do_pass_robot,
              "call robot": do_call_robot,
              "wait for robot": do_wait_for_robot,
              "reset": do_reset}


def get_rosbag_from_file(filename, mode="r"):
    try:
        bag = rosbag.Bag(filename, mode)
        return bag
    except Exception as e:
        print(
         "Failed to get rosbag topics info from file {:} with exception: '{:}'"
         .format(filename, e)
        )
        return None


class Player(Thread):
    def __init__(self, filename, topics=[], start_time=None, duration=None):
        super(Player, self).__init__()
        self.bag = get_rosbag_from_file(filename)
        bag_start_time = self.bag.get_start_time()
        self.msgs = self.bag.read_messages(topics=topics)

        self.pubs = {}
        self.duration = duration
        self.start_timestamp = (
            bag_start_time + start_time
            if start_time is not None
            else bag_start_time
        )

    def run(self):
        for topic, msg, timestamp in self.msgs:

            # topic = "/human_actions_old"
            secs = timestamp.to_sec()
            #     if secs >= start_time and secs <= end_time:
            if topic not in self.pubs:
                self.pubs[topic] = rospy.Publisher(
                    topic, msg.__class__, queue_size=10
                )
                rospy.sleep(0.05)
            if (secs >= self.start_timestamp) and (
                self.duration is None
                or secs < self.start_timestamp + self.duration
            ):
                self.pubs[topic].publish(msg)
                rospy.sleep(SLEEP)

    def close(self):
        self.bag.close()

    def terminate(self):
        self.bag.terminate()
        rospy.sleep(1)
        if self.bag.poll() is None:
            self.bag.kill()
        self.bag.close()


def convert_bags(config):
    out_paths = []
    for key, behaviour in config.behaviours.items():
        if behaviour["type"] == "rosbag":
            for topic in behaviour["topics"]:
                msgs = []
                start_time = behaviour["start"]
                end_time = start_time + behaviour["duration"]
                with rosbag.Bag(behaviour["filename"], "r") as in_bag:
                    bag_time = in_bag.get_start_time()
                    for topic, msg, t in in_bag.read_messages(topics=[topic]):
                        secs = t.to_sec() - bag_time - start_time
                        if secs >= 0 and secs <= end_time - start_time:
                            msg.header.stamp = rospy.Time.from_sec(secs)
                            msgs.append(msg)
                msgs = sorted(msgs, key=lambda msg: msg.header.seq)
                try:
                    os.mkdir(behaviour["filename"][:-4])
                except Exception:
                    pass
                out_path = os.path.join(
                    behaviour["filename"][:-4],
                    "{:}-{:}.bag".format(behaviour["label"], start_time),
                )
                behaviour["filename"] = out_path
                behaviour["start"] = 0
                out_paths.append(out_path)
                with rosbag.Bag(out_path, "w") as out_bag:
                    for msg in msgs:
                        out_bag.write(topic, msg, msg.header.stamp)
            return out_paths


class PickerSimulator(object):

    def __init__(self):
        self.publisher = rospy.Publisher('/hedge_pos_a',
                                         hedge_pos_a, queue_size=10)
        self.human_action_pub = rospy.Publisher('{}/human_actions'.format(NS),
                                                Action, queue_size=10)
        self.behaviours = rospy.get_param("{}/behaviours".format(NS))
        # self.behaviour_times = sorted(self.behaviours.keys())
        self.behaviour = do_reset
        self.old_behaviour = do_reset
        self.counter = 0
        # self.initial_x = 17.561 #20.639 # 17.061
        # self.initial_y = 4.609 #4.628 # 4.609
        do_reset(self)
        self.wait = 0
        self.return1 = False
        self.play_rosbags = False
        self.running_bags = []
        self.robot_pose_sub = rospy.Subscriber(
            "{}/robot_pose".format(NS.rstrip("/hri")),
            Pose,
            self.robot_position_coordinate_callback,
        )
        self.last_clock = rospy.get_time()
        self.wait_time = int(self.last_clock + 3)

    def robot_position_coordinate_callback(self, pose):
        self.robot_x = pose.position.x
        self.robot_y = pose.position.y

    def get_distance_to_robot(self):
        dx = self.x - self.robot_x
        dy = self.y - self.robot_y
        dxs = dx * dx
        dys = dy * dy
        if dxs > dys:
            return sqrt(dxs + dys) - 0.5 * (PICKER_LENGTH + ROBOT_LENGTH)
        else:
            return sqrt(dxs + dys) - 0.5 * (PICKER_WIDTH + ROBOT_WIDTH)

    # def get_next_behaviour(self):
    #     return self.behaviours[self.behaviour_times.pop(0)]

    # def get_next_behaviour_time(self):
    #     try:
    #         return self.behaviour_times[0]
    #     except IndexError:
    #         return float('inf')

    def send_position_message(self):
        msg = hedge_pos_a()
        msg.address = PICKER_ID
        msg.x_m = self.x
        msg.y_m = self.y
        msg.z_m = self.orientation
        self.publisher.publish(msg)

    def loop(self):
        self.send_position_message()
        done = self.behaviour(self)
        # if (self.old_behaviour != self.behaviour):
            # db.add_person_entry(rospy.get_time(), self.x, self.y,
                                # self.orientation, self.behaviour)
        now = rospy.get_time()
        while (done and now >= self.wait_time):
            done = False
            try:
                behaviour, self.wait_time = self.behaviours.pop(0)
                self.wait_time += now
                self.switch_behaviour(behaviour)
                if self.play_rosbags:
                    rospy.loginfo("PSI: Playing rosbag '{}'".format(
                                    ACTIONS[behaviour]["rosbag"]["filepath"]))
                    player = Player(
                                ACTIONS[behaviour]["rosbag"]["filepath"],
                                topics=ACTIONS[behaviour]["rosbag"]["topics"],
                                start_time=ACTIONS[behaviour]["rosbag"]["start"],
                                duration=ACTIONS[behaviour]["rosbag"]["duration"])
                    player.start()
                    self.running_bags.append(player)
            except IndexError:
                break

    # scenarios: "deliver, exchange"
    # actions: "pick berries", "wait for robot", "wave to robot", "approach",
    # "leave"

    def switch_behaviour(self, behaviour):
        if behaviour in BEHAVIOURS:
            self.counter = 0
            self.old_behaviour = self.behaviour
            self.behaviour = BEHAVIOURS.get(
                behaviour, lambda: rospy.logerr("PSI: Unknown behaviour"))
            rospy.loginfo("PMO: Switched picker behaviour to '{:}'.".format(
                           behaviour))
            # rospy.loginfo(("PMO: Switched to behaviour '{:}',"
            #                " next behaviour is '{:}' at {:.2f}").format(
            #                behaviour, self.behaviours[0][0], self.wait_time))
        else:
            rospy.logwarn(
                "PMO: Received unknown movement behaviour {:}, ignoring input"
                .format(behaviour))

    # def update_position(self):
    #     if self.strategy == "at robot":
    #         if self.old_strategy == "evade":
    #             self.switch_strategy("stand")
    #         elif self.old_strategy == "exchange":
    #             self.counter = EXCHANGE_COUNTS
    #             self.switch_strategy("exchange")
    #         elif self.old_strategy == "deliver":
    #             self.counter = DELIVER_COUNTS
    #             self.switch_strategy("deliver")
    #     elif self.strategy == "return":
    #         if self.x < self.initial_x:
    #             self.x += X_DISTANCE
    #             self.y += Y_DISTANCE
    #         else:
    #             self.counter = 0
    #             self.switch_strategy("stand")
    #     elif self.strategy == "reset":
    #         self.x = self.initial_x
    #         self.y = self.initial_y
    #     elif self.strategy == "stand":
    #         pass
    #     elif self.strategy == "evade":
    #         if self.counter < EVADE_COUNTS:
    #             self.x -= X_DISTANCE
    #             self.y -= Y_DISTANCE
    #             self.counter += 1
    #         else:
    #             self.counter = 0
    #             self.switch_strategy("stand")
    #     elif self.strategy == "exchange":
    #         if self.counter < EXCHANGE_COUNTS:
    #             self.x -= X_DISTANCE
    #             self.y -= Y_DISTANCE
    #             self.counter += 1
    #             self.wait = 0
    #         elif self.counter == EXCHANGE_COUNTS:
    #             if self.wait < EXCHANGE_WAIT_COUNTS:
    #                 self.wait += 1
    #             else:
    #                 self.y += X_DISTANCE
    #                 self.y += Y_DISTANCE
    #                 self.switch_strategy("return")
    #     elif self.strategy == "deliver":
    #         if self.counter < DELIVER_COUNTS:
    #             self.x -= X_DISTANCE
    #             self.y -= Y_DISTANCE
    #             self.counter += 1
    #             self.wait = 0
    #         elif self.counter == DELIVER_COUNTS:
    #             if self.wait < DELIVER_WAIT_COUNTS:
    #                 self.wait += 1
    #             else:
    #                 self.x += X_DISTANCE
    #                 self.y += Y_DISTANCE
    #                 self.switch_strategy("return")

    def spin(self):
        """
        Blocks until ROS node is shutdown. Yields activity to other threads.
        @raise ROSInitException: if node is not in a properly initialized state
        """

        if not rospy.core.is_initialized():
            raise rospy.exceptions.ROSInitException(
                "client code must call rospy.init_node() first")
            rospy.logdebug(
                "node[%s, %s] entering spin(), pid[%s]",
                rospy.core.get_caller_id(),
                rospy.core.get_node_uri(), os.getpid())
        try:
            while not rospy.core.is_shutdown():
                self.loop()
                rospy.rostime.wallsleep(1.0 / FREQUENCY)
            self.shutdown()
        except KeyboardInterrupt:
            rospy.logdebug("keyboard interrupt, shutting down")
            self.shutdown()
            rospy.core.signal_shutdown('keyboard interrupt')

    def terminate_bags(self):
        for player in self.running_bags:
            player.terminate()
            player.join()
        self.running_bags = []
        for bag in self.bags.values():
            bag.close()

    def shutdown(self):
        if self.play_rosbags:
            self.terminate_bags()


if __name__ == '__main__':
    rospy.init_node("picker_mover")
    # doesn't work before init_node

    rospy.myargv(argv=sys.argv)
    while (rospy.get_time() == 0):
        sleep(0.01)
    rospy.loginfo("PMO: Picker Mover started")
    pm = PickerSimulator()
    pm.spin()
