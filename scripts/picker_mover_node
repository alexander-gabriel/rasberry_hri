#!/usr/bin/env python

import sys
import os
from math import sin, cos
from time import sleep

import rospy
from std_msgs.msg import String

from marvelmind_nav.msg import hedge_pos_a

MEAN_WAYPOINT_DISTANCE = rospy.get_param("mean_waypoint_distance", 2.95) # m
FREQUENCY = 10 # Hz  1/s
SPEED = rospy.get_param("picker_speed", 1.3) # m/s
PICKER_ID = 2
EVADE_DISTANCE = 2 * MEAN_WAYPOINT_DISTANCE # m
DELIVER_DISTANCE = 1 * MEAN_WAYPOINT_DISTANCE # m
DELIVER_COUNTS = int(DELIVER_DISTANCE / SPEED * FREQUENCY)
EXCHANGE_WAIT_COUNTS = rospy.get_param("exchange_cost", 5) * FREQUENCY
GIVE_WAIT_COUNTS = rospy.get_param("give_cost", 5) * FREQUENCY
ANGLE = 0.0 # angle between direction of travel and X coordinate

#102: 8.675 4.65
#103: 11.649 4.64
#104: 14.12 4.612
#105: 17.061 4.609
#106: 19.997 4.568

class PickerMover(object):

    def __init__(self):
        self.subscriber = rospy.Subscriber("/picker_mover", String, self.command_callback)
        self.publisher = rospy.Publisher('/hedge_pos_a', hedge_pos_a, queue_size=10)
        self.switch_strategy("stand")
        self.counter = 0
        self.x = 20.639
        self.y = 4.628
        self.wait = 0
        self.return1 = False


    def command_callback(self, msg):
        self.counter = 0
        self.switch_strategy(msg.data)


    def switch_strategy(self, strategy):
        if strategy in ["exchange", "give", "evade", "stand", "reset"]:
            self.strategy = strategy
            rospy.loginfo("PMO: Switched to movement strategy {:}".format(strategy))
        else:
            rospy.logwarn("PMO: Received unknown movement strategy {:}, ignoring input".format(strategy))


    def update_position(self):
        if self.strategy == "reset":
            self.x = self.initial_x
            self.y = self.initial_y
        elif self.strategy == "stand":
            pass
        elif self.strategy == "evade":
            if self.counter < EVADE_DISTANCE / SPEED * FREQUENCY:
                self.x = self.x - cos(ANGLE) * SPEED / FREQUENCY
                self.y = self.y - sin(ANGLE) * SPEED / FREQUENCY
                self.counter += 1
            else:
                self.counter = 0
        elif self.strategy == "exchange":
            if self.counter < DELIVER_COUNTS and self.return1 == False:
                self.x = self.x - cos(ANGLE) * SPEED / FREQUENCY
                self.y = self.y - sin(ANGLE) * SPEED / FREQUENCY
                self.counter += 1
                self.wait = 0
            elif self.counter == DELIVER_COUNTS:
                if self.wait < EXCHANGE_WAIT_COUNTS:
                    self.wait += 1
                else:
                    self.x = self.x + cos(ANGLE) * SPEED / FREQUENCY
                    self.y = self.y + sin(ANGLE) * SPEED / FREQUENCY
                    self.counter += 1
                    self.return1 = True
            elif self.counter < 2 * DELIVER_COUNTS and self.return1 == True:
                self.x = self.x + cos(ANGLE) * SPEED / FREQUENCY
                self.y = self.y + sin(ANGLE) * SPEED / FREQUENCY
                self.counter += 1
            else:
                self.return1 = False
                self.counter = 0
                self.switch_strategy("stand")
        elif self.strategy == "give":
            if self.counter < DELIVER_COUNTS and self.return1 == False:
                self.x = self.x - cos(ANGLE) * SPEED / FREQUENCY
                self.y = self.y - sin(ANGLE) * SPEED / FREQUENCY
                self.counter += 1
                self.wait = 0
            elif self.counter == DELIVER_COUNTS:
                if self.wait < GIVE_WAIT_COUNTS:
                    self.wait += 1
                else:
                    self.x = self.x + cos(ANGLE) * SPEED / FREQUENCY
                    self.y = self.y + sin(ANGLE) * SPEED / FREQUENCY
                    self.counter += 1
                    self.return1 = True
            elif self.counter < 2 * DELIVER_COUNTS and self.return1 == True:
                self.x = self.x + cos(ANGLE) * SPEED / FREQUENCY
                self.y = self.y + sin(ANGLE) * SPEED / FREQUENCY
                self.counter += 1
            else:
                self.return1 = False
                self.counter = 0
                self.switch_strategy("stand")


    def loop(self):
        msg = hedge_pos_a()
        msg.address = PICKER_ID
        msg.x_m = self.x
        msg.y_m = self.y
        self.publisher.publish(msg)
        self.update_position()


    def spin(self):
        """
        Blocks until ROS node is shutdown. Yields activity to other threads.
        @raise ROSInitException: if node is not in a properly initialized state
        """

        if not rospy.core.is_initialized():
            raise rospy.exceptions.ROSInitException("client code must call rospy.init_node() first")
            rospy.logdebug("node[%s, %s] entering spin(), pid[%s]", rospy.core.get_caller_id(), rospy.core.get_node_uri(), os.getpid())
        try:
            while not rospy.core.is_shutdown():
                self.loop()
                rospy.rostime.wallsleep(1.0/FREQUENCY)
        except KeyboardInterrupt:
            rospy.logdebug("keyboard interrupt, shutting down")
            rospy.core.signal_shutdown('keyboard interrupt')



if __name__ == '__main__':
    rospy.init_node("picker_mover")
    rospy.myargv(argv=sys.argv)
    rospy.loginfo("PMO: Picker Mover started")

    pm = PickerMover()
    pm.spin()
