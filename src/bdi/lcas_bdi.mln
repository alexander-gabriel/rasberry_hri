class = {Human, Robot, Plant, Object, Crate}


// --- predicates ---

is_a(thing,class!)
is_mobile(thing)
has_role(thing,role?)

//tpcc
sam(place,place) // same position
dou(place,place) //same position
tri(place,place) //same position
// left back: less left than back; back left: less back than left <- importance increasing to the right

//close
clb(place,place) // close left back
cbl(place,place) // close back left
csl(place,place) // close straight left  -- left
cfl(place,place) // close front left
clf(place,place) // close left front
csf(place,place) // close straight front  -- before
crf(place,place) // close right front
cfr(place,place) // close front right
csr(place,place) // close straight right  -- right
cbr(place,place) // close back right
crb(place,place) // close right back
csb(place,place) // close straight back  -- behind

//distant
dlb(place,place) // distant left back
dbl(place,place) // distant back left
dsl(place,place) // distant straight left  -- left
dfl(place,place) // distant front left
dlf(place,place) // distant left front
dsf(place,place) // distant straight front  -- before
drf(place,place) // distant right front
dfr(place,place) // distant front right
dsr(place,place) // distant straight right  -- right
dbr(place,place) // distant back right
drb(place,place) // distant right back
dsb(place,place) // distant straight back -- behind

// location predicates
is_at(thing,place!)
colocated(thing,thing)
can_reach(thing,thing)
moveTo(thing,thing)
is_near(thing,thing)
is_facing(thing,thing)
leads_to(place,place)
free_path(place,place)
linked(place,place)
carries_berries(place)


// crate status predicates
has_crate(thing)
has_requested_crate(thing)


///formulas


//basic abilities and desires

#fixweight
is_a(?mobile,Robot) v is_a(?mobile,Human) <=> is_mobile(?mobile).
#fixweight
!is_a(?nonhuman,Human) => !(has_requested_crate(?nonhuman) v has_crate(?nonhuman)).

//location reasoning

#fixweight
?place1=?place2 => (!leads_to(?place1,?place2) ^ !free_path(?place1,?place2)).

#fixweight
leads_to(?place1,?place2) => linked(?place1,?place2).
#fixweight
linked(?place1,?place2) ^ linked(?place2,?place3) ^ ?place1=/=?place3 => linked(?place1,?place3).

leads_to(?place1,?place2) ^ !(EXIST ?thing (is_at(?thing,?place2))) ^ (free_path(?place2,?place3) v ?place2=place3) => free_path(?place1,?place3).

#fixweight
?mobile=/=?object ^ is_at(?mobile,?place1) ^ is_mobile(?mobile) ^ is_at(?object,?place2) ^ (free_path(?place1,?place2) v leads_to(?place1,?place2)) => can_reach(?mobile,?object).
#fixweight
is_at(?thing,?place1) ^ is_at(?object,?place2) ^ (!(free_path(?place1,?place2) v leads_to(?place1,?place2)) v !is_mobile(?thing)) => !can_reach(?thing,?object).

#fixweight
?thing1=/=?thing2 ^ is_at(?thing1,?place1) ^ is_at(?thing2,?place1) => colocated(?thing1,?thing2).
#fixweight
?thing1=/=?thing2 ^ ?place1=/=?place2 ^ is_at(?thing1,?place1) ^ is_at(?thing2,?place2) => !colocated(?thing1,?thing2).


// crate logic



#fixweight
has_crate(?human) => !has_requested_crate(?human).

// -- scenarios --

// bring crate
#fixweight
is_a(?human,Human) ^ is_a(?robot,Robot) ^ has_requested_crate(?human) ^ can_reach(?robot,?human) => moveTo(?robot,?human).
is_a(?human,Human) ^ is_a(?robot,Robot) ^ (!has_requested_crate(?human) v !can_reach(?robot,?human)) => !moveTo(?robot,?human).


// make way
#fixweight
is_a(?human,Human) ^ is_a(?robot,Robot) ^ is_a(?plant,Plant) ^ has_crate(?human) ^ !can_reach(?human,?plant) ^ can_reach(?robot, ?plant) ^ can_reach(?human,?robot) => moveTo(?robot,?plant).


// approach setting
#fixweight
is_a(?human,Human) ^ is_a(?robot,Robot) ^ is_a(?crate,Crate) ^ !has_crate(?human) ^ can_reach(?human,?robot) ^ !can_reach(?human,?crate) ^ can_reach(?robot,?crate) => moveTo(?robot,?crate).
