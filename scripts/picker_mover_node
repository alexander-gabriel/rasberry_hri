#!/usr/bin/env python

import sys
import os
from math import sin, cos
from time import sleep

import rospy
from std_msgs.msg import String
from marvelmind_nav.msg import hedge_pos_a


MEAN_WAYPOINT_DISTANCE = rospy.get_param("/thorvald_001/hri/mean_waypoint_distance", 2.95) # m
FREQUENCY = 10 # Hz  1/s
PICKER_SPEED = rospy.get_param("/thorvald_001/hri/picker_speed", 1.3) # m/s
PICKER_ID = 2

EVADE_DISTANCE = 2 * MEAN_WAYPOINT_DISTANCE # m
EVADE_COUNTS = int(EVADE_DISTANCE / PICKER_SPEED * FREQUENCY)

DELIVER_DISTANCE = 1 * MEAN_WAYPOINT_DISTANCE # m
DELIVER_COUNTS = int(DELIVER_DISTANCE / PICKER_SPEED * FREQUENCY)

EXCHANGE_DISTANCE = 1 * MEAN_WAYPOINT_DISTANCE # m
EXCHANGE_COUNTS = int(EXCHANGE_DISTANCE / PICKER_SPEED * FREQUENCY)
EXCHANGE_WAIT_COUNTS = rospy.get_param("/thorvald_001/hri/exchange_cost", 5) * FREQUENCY
DELIVER_WAIT_COUNTS = rospy.get_param("/thorvald_001/hri/give_cost", 5) * FREQUENCY


ANGLE = 0.0 # angle between direction of travel and X coordinate
X_DISTANCE = cos(ANGLE) * PICKER_SPEED / FREQUENCY
Y_DISTANCE = sin(ANGLE) * PICKER_SPEED / FREQUENCY
#102: 8.675 4.65
#103: 11.649 4.64
#104: 14.12 4.612
#105: 17.061 4.609
#106: 19.997 4.568

class PickerMover(object):

    def __init__(self):
        self.subscriber = rospy.Subscriber("/picker_mover", String, self.command_callback)
        self.publisher = rospy.Publisher('/hedge_pos_a', hedge_pos_a, queue_size=10)
        self.strategy = "stand"
        self.counter = 0
        self.initial_x = 17.061 #20.639
        self.initial_y = 4.609 #4.628
        self.x = self.initial_x
        self.y = self.initial_y
        self.wait = 0
        self.return1 = False


    def command_callback(self, msg):
        self.counter = 0
        self.switch_strategy(msg.data)


    def switch_strategy(self, strategy):
        if strategy in ["exchange", "deliver", "evade", "stand", "reset", "at robot", "return"]:
            self.old_strategy = self.strategy
            self.strategy = strategy
            rospy.loginfo("PMO: Switched to movement strategy {:}".format(strategy))
        else:
            rospy.logwarn("PMO: Received unknown movement strategy {:}, ignoring input".format(strategy))


    def update_position(self):
        if self.strategy == "at robot":
            if self.old_strategy == "evade":
                self.switch_strategy("stand")
            elif self.old_strategy == "exchange":
                self.counter = EXCHANGE_COUNTS
                self.switch_strategy("exchange")
            elif self.old_strategy == "deliver":
                self.counter = DELIVER_COUNTS
                self.switch_strategy("deliver")
        elif self.strategy == "return":
            if self.x < self.initial_x:
                self.x += X_DISTANCE
                self.y += Y_DISTANCE
            else:
                self.counter = 0
                self.switch_strategy("stand")
        elif self.strategy == "reset":
            self.x = self.initial_x
            self.y = self.initial_y
        elif self.strategy == "stand":
            pass
        elif self.strategy == "evade":
            if self.counter < EVADE_COUNTS:
                self.x -= X_DISTANCE
                self.y -= Y_DISTANCE
                self.counter += 1
            else:
                self.counter = 0
                self.switch_strategy("stand")
        elif self.strategy == "exchange":
            if self.counter < EXCHANGE_COUNTS:
                self.x -= X_DISTANCE
                self.y -= Y_DISTANCE
                self.counter += 1
                self.wait = 0
            elif self.counter == EXCHANGE_COUNTS:
                if self.wait < EXCHANGE_WAIT_COUNTS:
                    self.wait += 1
                else:
                    self.y += X_DISTANCE
                    self.y += Y_DISTANCE
                    self.switch_strategy("return")
        elif self.strategy == "deliver":
            if self.counter < DELIVER_COUNTS:
                self.x -= X_DISTANCE
                self.y -= Y_DISTANCE
                self.counter += 1
                self.wait = 0
            elif self.counter == DELIVER_COUNTS:
                if self.wait < DELIVER_WAIT_COUNTS:
                    self.wait += 1
                else:
                    self.x += X_DISTANCE
                    self.y += Y_DISTANCE
                    self.switch_strategy("return")


    def loop(self):
        msg = hedge_pos_a()
        msg.address = PICKER_ID
        msg.x_m = self.x
        msg.y_m = self.y
        self.publisher.publish(msg)
        self.update_position()


    def spin(self):
        """
        Blocks until ROS node is shutdown. Yields activity to other threads.
        @raise ROSInitException: if node is not in a properly initialized state
        """

        if not rospy.core.is_initialized():
            raise rospy.exceptions.ROSInitException("client code must call rospy.init_node() first")
            rospy.logdebug("node[%s, %s] entering spin(), pid[%s]", rospy.core.get_caller_id(), rospy.core.get_node_uri(), os.getpid())
        try:
            while not rospy.core.is_shutdown():
                self.loop()
                rospy.rostime.wallsleep(1.0/FREQUENCY)
        except KeyboardInterrupt:
            rospy.logdebug("keyboard interrupt, shutting down")
            rospy.core.signal_shutdown('keyboard interrupt')



if __name__ == '__main__':
    rospy.init_node("picker_mover")
    rospy.myargv(argv=sys.argv)
    rospy.loginfo("PMO: Picker Mover started")

    pm = PickerMover()
    pm.spin()
