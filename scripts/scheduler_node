#! /usr/bin/python
# import rospy
from pracmln import MLN, Database, MLNQuery
from pracmln.mln import Predicate
from pracmln.utils.project import PRACMLNConfig, MLNProject
MLN_FILENAME = "lcas_bdi.mln"
DB_FILENAME = "lcas_bdi.db"
TRUTH_THRESHOLD = 0.5
VERBOSE = False
INF = float('inf')

class OrderedConsistentSet:

    def __init__(self):
        self.items = []


    def append(self, item):
        if not item in self.items:
            try:
                if item.startswith("!"):
                    self.items.remove(item[1:])
                else:
                    self.items.remove("!" + item)
            except ValueError:
                pass
            self.items.append(item)


    def __iadd__(self, other):
        for item in other:
            self.append(item)
        return self


    def __contains__(self, key):
        return key in self.items


    def __str__(self):
        return self.items.__str__()


    def __iter__(self):
        return self.items.__iter__()



class Action:

    conditions = []
    consequences = []



class Goal:

    subgoals = [] # list of subgoals (only if there is no action to be performed)
    action = None # action to be performed (only if there are no subgoals)

    def __init__(self, world_state):
        self.world_state = world_state


    def get_conditions(self):
        try:
            return self.action.conditions
        except AttributeError:
            try:
                return self.conditions
            except AttributeError:
                self.conditions = OrderedConsistentSet()
                consequences = OrderedConsistentSet()
                for subgoal in self.subgoals:
                    new_conditions = subgoal.get_conditions()
                    for condition in new_conditions:
                        if not condition in consequences:
                            self.conditions.append(condition)
                    consequences += subgoal.get_consequences()
                return self.conditions


    def get_consequences(self):
        try:
            return self.action.consequences
        except AttributeError:
            try:
                return self.consequences
            except AttributeError:
                self.consequences = OrderedConsistentSet()
                for subgoal in self.subgoals:
                    self.consequences += subgoal.get_consequences()
                return self.consequences


    def is_achievable(self):
        query = ""
        for condition in self.get_conditions():
            query += condition + " ^ "
        query = query[:-3]
        result = self.world_state.check(query)
        print(query)
        print(result.result_dict())
            # if self.world_state.truth(condition) < TRUTH_THRESHOLD:
            #     return False
        return True


    def is_achieved(self):
        for consequence in self.get_consequences():
            if self.world_state.truth(consequence) < TRUTH_THRESHOLD:
                return False
        return True #TODO cache result


    def get_action_queue(self):
        try:
            return self.action_queue
        except AttributeError:
            try:
                self.action_queue = [self.action]
            except AttributeError:
                self.action_queue = []
                for subgoal in self.subgoals:
                    self.action_queue += subgoal.get_action_queue()
        return self.action_queue


    def get_next_action(self):
        return self.get_action_queue()[0]


    def perform_action(self):
        action = self.get_action_queue().pop()
        action.perform()


    def get_cost(self):
        try:
            return self.cost
        except AttributeError:
            try:
                self.cost = self.action.get_cost()
            except AttributeError:
                self.cost = 0
                for subgoal in self.subgoals:
                    self.cost += subgoal.get_cost()
        return self.cost


    def get_gain(self):
        try:
            return self.gain
        except AttributeError:
            try:
                self.gain = self.action.gain
            except AttributeError:
                self.gain = 0
                for subgoal in self.subgoals:
                    self.gain += subgoal.get_gain()
        return self.gain



class WorldState():

    def __init__(self):
        self.mln = MLN(mlnfile=MLN_FILENAME, grammar='PRACGrammar', logic='FirstOrderLogic')
        self.db = Database(self.mln, dbfile=DB_FILENAME)
        self.query = MLNQuery(mln=self.mln, db=self.db, verbose=VERBOSE)
        self.query._config['method'] = 'WCSP (exact MPE with toulbar2)'
        self.query._config['multicore'] = True


    def get_probability(self, belief, threshhold):
        return self.db.query(belief, threshhold)


    def set_probability(self, belief, strength):
        self.db[belief] = strength


    def abandon_belief(self, belief):
        del self.db[belief]


    def reason(self):
        self.query._config['queries'] = None
        result = self.query.run()
        for evidence, truth in result.result_dict().items():
            bdi.world_state.db.add(evidence, truth)


    def check(self, queries):
        self.query._config['queries'] = queries
        result = self.query.run()
        # for evidence, truth in result.result_dict().items():
        #     bdi.world_state.db.add(evidence, truth)
        return result


    def print(self):
        self.db.write()


    def truth(self, atom):
        return self.mln.truth(atom)


    def add_constant(self, domain, constants):
        self.mln.constant(domain, constants)


    def add_predicate(self, predicate):
        self.mln.declare_predicate(predicate)


    def add_formula(self, formula, weight, fixweight=True):
        self.mln.formula(formula=formula, weight=weight, fixweight=fixweight, unique_templvars=None)


    def ground(self):
        return self.mln.ground(self.db)


    def learn(self):
        # 'WCSP (exact MPE with toulbar2)'
        self.mln.learn([self.db], method="<class 'pracmln.mln.learning.bpll.BPLL'>", **params)


    def _materialize(self):
        self.mln.materialize(self.db)


    def save(self):
        with open(DB_FILENAME, "w") as file:
            self.db.write(file, bars=False)
        self.mln.tofile(MLN_FILENAME)


    def write_mln(self):
        self.mln.write()


    def write_evidence(self):
        self.db.write()


    def write(self):
        self.write_mln()
        print("-------------------------------------------------------------------")
        self.write_evidence()



class BDISystem:

    goals = []
    intentions = []

    def __init__(self, me):
        self.me = me
        self.world_state = WorldState()


    def generate_options(self):
        # consider result of current intention
        desires = []
        for goal in self.goals:
            if not goal.is_achievable(self.world_state):
                desires.append(goal)
        for goal in self.intentions:
            if goal in desires and goal.is_achieved():
                desires.remove(goal)
        return desires


    def filter(desires):
        return intentions # select next intention


    def perform_action(self):
        next_goal = None
        min_cost = None
        for goal in self.intentions:
            action = goal.get_next_action()
            cost = action.get_cost()
            if cost < min_cost:
                next_goal = goal
                min_cost  = cost
        next_goal.perform_action()


    def loop(self):
        desires = self.generate_options()
        self.intention = self.filter(desires)
        self.select_action()


    def write(self):
        self.world_state.write()


    def save(self):
        self.world_state.save()



def setup(bdi, me):
    bdi.world_state.add_formula("is_a({:}, Robot)".format(me), INF)

    pickup = Action()
    pickup.conditions = ["is_a(?x, Human)", "has_requested_crate(?x)", "in_front_of(?x, {:})".format(me)]
    pickup.consequences = ["has_crate(?x)", "!has_requested_crate(?x)", "!has_crate({:})".format(me)]
    pickup_goal = Goal(bdi.world_state)
    pickup_goal.action = pickup

    move_to = Action()
    move_to.conditions = ["!in_front_of(?x, {:})".format(me), "can_reach({:}, ?x)".format(me)]
    move_to.consequences = ["in_front_of(?x, {:})".format(me)]
    move_to_goal = Goal(bdi.world_state)
    move_to_goal.action = move_to

    move_away = Action()
    move_away.conditions = ["in_front_of(?x, {:})".format(me)]
    move_away.consequences = ["!in_front_of(?x, {:})".format(me)]
    move_away_goal = Goal(bdi.world_state)
    move_away_goal.action = move_away

    deliver_crate = Goal(bdi.world_state)
    deliver_crate.subgoals.append(move_to_goal)
    deliver_crate.subgoals.append(pickup_goal)
    deliver_crate.subgoals.append(move_away_goal)

    print(deliver_crate.is_achievable())

# def spin():
#     """
#     Blocks until ROS node is shutdown. Yields activity to other threads.
#     @raise ROSInitException: if node is not in a properly initialized state
#     """
#
#     if not rospy.core.is_initialized():
#         raise rospy.exceptions.ROSInitException("client code must call rospy.init_node() first")
#     logdebug("node[%s, %s] entering spin(), pid[%s]", rospy.core.get_caller_id(), rospy.core.get_node_uri(), os.getpid())
#     try:
#         while not rospy.core.is_shutdown():
#             loop()
#             rospy.rostime.wallsleep(0.5)
#     except KeyboardInterrupt:
#         logdebug("keyboard interrupt, shutting down")
#         rospy.core.signal_shutdown('keyboard interrupt')

if '__main__' == __name__:
    # rospy.init_node("scheduler")
    bdi = BDISystem("Thorvald019")
    bdi.world_state.add_formula("in_front_of(?x, ?y) => !in_front_of(?y, ?x)", INF)
    bdi.world_state.add_formula("has_crate(?x) => !has_requested_crate(?x)", INF)
    bdi.world_state.db.retract("!in_front_of(Peter, Thorvald)")
    bdi.world_state.db.add("!has_requested_crate(Peter)")

    # bdi.world_state.add_formula("is_a(Peter, Human)", 1.0)
    bdi.write()
    # bdi.write()
    # print(bdi.world_state.query.mln.predicate("in_front_of"))
    setup(bdi,"Thorvald019")
    # bdi.world_state.reason()

    # bdi.spin()
    # bdi.save()
