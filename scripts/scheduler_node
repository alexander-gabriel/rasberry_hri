#! /usr/bin/python
# import rospy
from pracmln import MLN, Database, MLNQuery
from pracmln.mln import Predicate
from pracmln.utils.project import PRACMLNConfig, MLNProject
MLN_FILENAME = "lcas_bdi.mln"
DB_FILENAME = "lcas_bdi.db"
TRUTH_THRESHOLD = 0.5
TARGET = "?target"
VERBOSE = False
INF = float('inf')

MAX_COST = 1.0
MIN_GAIN = 1.0

class OrderedConsistentSet:

    def __init__(self):
        self.items = []


    def append(self, item):
        if not item in self.items:
            try:
                if item.startswith("!"):
                    self.items.remove(item[1:])
                else:
                    self.items.remove("!" + item)
            except ValueError:
                pass
            self.items.append(item)


    def __iadd__(self, other):
        for item in other:
            self.append(item)
        return self


    def __contains__(self, key):
        return key in self.items


    def __str__(self):
        return self.items.__str__()


    def __iter__(self):
        return self.items.__iter__()



class Action:

    conditions = []
    consequences = []
    label = ""
    gain = 1.5

    def perform(self, world_state, target):
        print(self.label)
        for consequence in self.consequences:
            world_state.db.add(consequence.replace(TARGET, target))

    def get_cost(self, target):
        return 0.0 # devise cost calculation



class Goal:

    subgoals = [] # list of subgoals (only if there is no action to be performed)
    action = None # action to be performed (only if there are no subgoals)
    instance = None

    def __init__(self, world_state, subgoals=[], action=None):
        self.world_state = world_state
        self.subgoals = subgoals
        self.action = action
        self.guide = self.get_instance_guide()


    def get_instance_guide(self):
        if not self.action is None:
            for condition in self.action.conditions:
                start = condition.find(TARGET)
                if start != -1:
                    end = start + len(TARGET)
                    prefix = condition[:start]
                    postfix = condition[end:]
                    return (prefix, postfix)
        else:
            for subgoal in self.subgoals:
                guide = subgoal.get_instance_guide()
                if not guide is None:
                    return guide
            return None


    def get_conditions(self):
        try:
            return self.action.conditions
        except AttributeError:
            try:
                return self.conditions
            except AttributeError:
                self.conditions = OrderedConsistentSet()
                consequences = OrderedConsistentSet()
                for subgoal in self.subgoals:
                    new_conditions = subgoal.get_conditions()
                    for condition in new_conditions:
                        if not condition in consequences:
                            self.conditions.append(condition)
                    consequences += subgoal.get_consequences()
                return self.conditions


    def get_consequences(self):
        try:
            return self.action.consequences
        except AttributeError:
            try:
                return self.consequences
            except AttributeError:
                self.consequences = OrderedConsistentSet()
                for subgoal in self.subgoals:
                    self.consequences += subgoal.get_consequences()
                return self.consequences


    def find_instances(self):
        query = ""
        for condition in self.get_conditions():
            query += condition + " ^ "
        query = query[:-3]
        result = self.world_state.check(query)
        targets = []
        for key, value in result.results.items():
            if not value is None:
                # print("{:}: {:d}".format(key,value))
                if not self.guide is None:
                    start = key.find(self.guide[0]) + len(self.guide[0])
                    end = key.find(self.guide[1])
                    target = key[start:end]
                    if not self.is_achieved(target):
                        targets.append(target)
        return targets


    def is_achieved(self, target):
        for consequence in self.get_consequences():
            truth = self.world_state.db.truth(consequence.replace(TARGET, target))
            if consequence.startswith("!"):
                if truth is None or truth > TRUTH_THRESHOLD:
                    return False
            else:
                if truth is None or truth <= TRUTH_THRESHOLD:
                    return False
        return True #TODO cache result


    def get_action_queue(self):
        try:
            return self.action_queue
        except AttributeError:
            if not self.action is None:
                self.action_queue = [self.action]
            else:
                self.action_queue = []
                for subgoal in self.subgoals:
                    self.action_queue += subgoal.get_action_queue()
        return self.action_queue


    def get_next_action(self):
        return self.get_action_queue()[0]


    def perform_action(self, target):
        action = self.get_action_queue().pop(0)
        action.perform(self.world_state, target)


    def get_cost(self, target):
        try:
            return self.cost
        except AttributeError:
            try:
                self.cost = self.action.get_cost(target)
            except AttributeError:
                self.cost = 0
                for subgoal in self.subgoals:
                    self.cost += subgoal.get_cost(target)
        return self.cost


    def get_gain(self, target):
        try:
            return self.gain
        except AttributeError:
            try:
                self.gain = self.action.gain
            except AttributeError:
                self.gain = 0
                for subgoal in self.subgoals:
                    self.gain += subgoal.get_gain(target)
        return self.gain



class WorldState():

    def __init__(self):
        self.mln = MLN(mlnfile=MLN_FILENAME, grammar='PRACGrammar', logic='FuzzyLogic')
        self.db = Database(self.mln, dbfile=DB_FILENAME)
        self.query = MLNQuery(mln=self.mln, db=self.db, verbose=VERBOSE)
        self.query._config['method'] = 'WCSP (exact MPE with toulbar2)'
        self.query._config['multicore'] = True


    def get_probability(self, belief, threshhold):
        return self.db.query(belief, threshhold)


    def set_probability(self, belief, strength):
        self.db[belief] = strength


    def abandon_belief(self, belief):
        del self.db[belief]


    def reason(self):
        self.query._config['queries'] = None
        result = self.query.run()
        for evidence, truth in result.result_dict().items():
            bdi.world_state.db.add(evidence, truth)


    def check(self, queries):
        self.query._config['queries'] = queries
        result = self.query.run()
        # for evidence, truth in result.result_dict().items():
        #     bdi.world_state.db.add(evidence, truth)
        return result


    def print(self):
        self.db.write()


    def truth(self, atom):
        return self.mln.truth(atom)


    def add_constant(self, domain, constants):
        self.mln.constant(domain, constants)


    def add_predicate(self, predicate):
        self.mln.declare_predicate(predicate)


    def add_formula(self, formula, weight, fixweight=True):
        self.mln.formula(formula=formula, weight=weight, fixweight=fixweight, unique_templvars=None)


    def ground(self):
        return self.mln.ground(self.db)


    def learn(self):
        # 'WCSP (exact MPE with toulbar2)'
        self.mln.learn([self.db], method="<class 'pracmln.mln.learning.bpll.BPLL'>", **params)


    def _materialize(self):
        self.mln.materialize(self.db)


    def save(self):
        with open(DB_FILENAME, "w") as file:
            self.db.write(file, bars=False)
        self.mln.tofile(MLN_FILENAME)


    def write_mln(self):
        self.mln.write()


    def write_evidence(self):
        self.db.write()


    def write(self):
        self.write_mln()
        print("-------------------------------------------------------------------")
        self.write_evidence()



class BDISystem:

    goals = []
    intentions = []

    def __init__(self, me):
        self.me = me
        self.world_state = WorldState()


    def generate_options(self):
        desires = []
        for goal in self.goals:
            targets = goal.find_instances()
            for target in targets:
                desires.append((goal, target))
        for intention in self.intentions:
            if intention in desires and intention[0].is_achieved(intention[1]):
                desires.remove(intention)
        return desires


    def filter(self, desires):
        intentions = []
        for desire in desires:
            gain = desire[0].get_gain(desire[1])
            cost = desire[0].get_cost(desire[1])
            if gain > MIN_GAIN and cost < MAX_COST:
                intentions.append(desire)
        return intentions


    def perform_action(self):
        chosen_intention = None
        min_cost = 999999
        for intention in self.intentions:
            action = intention[0].get_next_action()
            cost = action.get_cost(intention[1])
            if cost < min_cost:
                chosen_intention = intention
                min_cost  = cost
        if not chosen_intention is None:
            chosen_intention[0].perform_action(chosen_intention[1])


    def loop(self):
        desires = self.generate_options()
        self.intentions = self.filter(desires)
        self.perform_action()


    def write(self):
        self.world_state.write()


    def save(self):
        self.world_state.save()


    def add_goal(self, goal):
        self.goals.append(goal)



def setup(bdi, me):
    bdi.world_state.add_formula("is_a({:}, Robot)".format(me), INF)

    pickup = Action()
    pickup.label = "pickup"
    pickup.conditions = ["has_requested_crate({:})".format(TARGET), "in_front_of({:},{:})".format(TARGET, me)]
    pickup.consequences = ["has_crate({:})".format(TARGET), "!has_requested_crate({:})".format(TARGET), "!has_crate({:})".format(me)]
    pickup_goal = Goal(bdi.world_state, [], pickup)

    move_to = Action()
    move_to.label = "move to target"
    move_to.conditions = ["!in_front_of({:},{:})".format(TARGET, me), "can_reach({:},{:})".format(me, TARGET)]
    move_to.consequences = ["in_front_of({:},{:})".format(TARGET, me)]
    move_to_goal = Goal(bdi.world_state, [], move_to)

    move_away = Action()
    move_away.label = "move away from target"
    move_away.conditions = ["in_front_of({:},{:})".format(TARGET, me)]
    move_away.consequences = ["!in_front_of({:},{:})".format(TARGET, me)]
    move_away_goal = Goal(bdi.world_state, [], move_away)

    deliver_crate = Goal(bdi.world_state, [move_to_goal, pickup_goal, move_away_goal], None)

    bdi.add_goal(deliver_crate)
    # bdi.add_goal(pickup_goal)

# def spin():
#     """
#     Blocks until ROS node is shutdown. Yields activity to other threads.
#     @raise ROSInitException: if node is not in a properly initialized state
#     """
#
#     if not rospy.core.is_initialized():
#         raise rospy.exceptions.ROSInitException("client code must call rospy.init_node() first")
#     logdebug("node[%s, %s] entering spin(), pid[%s]", rospy.core.get_caller_id(), rospy.core.get_node_uri(), os.getpid())
#     try:
#         while not rospy.core.is_shutdown():
#             loop()
#             rospy.rostime.wallsleep(0.5)
#     except KeyboardInterrupt:
#         logdebug("keyboard interrupt, shutting down")
#         rospy.core.signal_shutdown('keyboard interrupt')

if '__main__' == __name__:
    # rospy.init_node("scheduler")
    bdi = BDISystem("Thorvald019")
    bdi.world_state.add_formula("in_front_of(?x, ?y) => !in_front_of(?y, ?x)", INF)
    bdi.world_state.add_formula("has_crate(?x) => !has_requested_crate(?x)", INF)



    # bdi.world_state.db.retract("has_requested_crate(Peter)")
    bdi.world_state.db.add("has_requested_crate(Peter)")

    # bdi.world_state.db.retract("!has_crate(Peter)")
    # bdi.world_state.db.add("has_crate(Peter)")

    # bdi.world_state.db.retract("has_crate(Thorvald019)")
    bdi.world_state.db.add("has_crate(Thorvald019)")

    # bdi.world_state.db.retract("!in_front_of(Peter,Thorvald019)")
    bdi.world_state.db.add("!in_front_of(Peter,Thorvald019)")

    bdi.world_state.db.add("can_reach(Thorvald019,Peter)")

    # bdi.world_state.add_formula("is_a(Peter, Human)", 1.0)
    # bdi.write()
    # print(bdi.world_state.query.mln.predicate("in_front_of"))
    setup(bdi,"Thorvald019")
    bdi.world_state.db.write()
    bdi.loop()
    bdi.world_state.db.write()
    bdi.loop()
    bdi.world_state.db.write()
    bdi.loop()
    bdi.world_state.db.write()

    # bdi.world_state.reason()

    # bdi.spin()
    # bdi.save()
